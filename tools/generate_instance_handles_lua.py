import os
import json
import re
from typing import Dict, Any, List, Tuple


INSTANCE_SUFFIXES = {
    '.moby.json': 'moby',
    '.controller.json': 'controller',
    '.path.json': 'path',
    '.volume.json': 'volume',
    '.clue.json': 'clue',
    '.area.json': 'area',
    '.pod.json': 'pod',
    '.scent.json': 'scent',
}


def _sanitize_var(name: str) -> str:
    # noms en minuscules, espaces -> _, supprimer ce qui n'est pas alphanum/underscore
    s = name.strip().lower().replace(' ', '_')
    s = re.sub(r"[^a-z0-9_]+", "_", s)
    # éviter nom vide
    return s if s else "inst"


def _tuid_to_args(tuid_value: Any) -> Tuple[int, int, int, int]:
    # Découper le TUID 64-bit en 4x u16 en ordre petit-boutiste: lo16, lo32>>16, hi32&0xFFFF, hi16
    tuid = int(tuid_value) & 0xFFFFFFFFFFFFFFFF
    a0 = tuid & 0xFFFF
    a1 = (tuid >> 16) & 0xFFFF
    a2 = (tuid >> 32) & 0xFFFF
    a3 = (tuid >> 48) & 0xFFFF
    return a0, a1, a2, a3


def _hex_tuid(value: Any) -> str:
    try:
        tuid = int(value)
        return f"0x{tuid:016X}"
    except Exception:
        return str(value)


def _collect_instances(root: str) -> List[Tuple[str, Dict[str, Any]]]:
    results: List[Tuple[str, Dict[str, Any]]] = []
    for base, _dirs, files in os.walk(root):
        for fn in files:
            for suf, typ in INSTANCE_SUFFIXES.items():
                if fn.endswith(suf):
                    p = os.path.join(base, fn)
                    try:
                        with open(p, 'r', encoding='utf-8') as f:
                            obj = json.load(f)
                        entry = {
                            'type': typ,
                            'tuid': obj.get('tuid'),
                            'name': obj.get('name') or os.path.splitext(os.path.splitext(fn)[0])[0],
                        }
                        results.append((typ, entry))
                    except Exception:
                        pass
                    break
    # Ordonner par type puis par TUID
    def _tuid_key(e):
        try:
            return int(e[1]['tuid'])
        except Exception:
            return 0
    results.sort(key=lambda t: (t[0], _tuid_key(t)))
    return results


def _emit_lua(instances: List[Tuple[str, Dict[str, Any]]]) -> str:
    lines: List[str] = []
    lines.append("-- This file was auto-generated by Polaris Editor toolchain\n")
    for typ, e in instances:
        tuid = e.get('tuid')
        if tuid is None:
            continue
        a0, a1, a2, a3 = _tuid_to_args(tuid)
        var_name = _sanitize_var(str(e.get('name') or 'inst')).lower()
        handle = f"{typ}_handle"
        # Format demandé: arguments en décimal (u16), commentaire TUID décimal
        try:
            tuid_dec = int(tuid)
        except Exception:
            tuid_dec = tuid
        lines.append(f"{var_name} = {handle}:new( {a0}, {a1}, {a2}, {a3} ); -- {tuid_dec}")
    lines.append("")
    return "\n".join(lines)


def generate_instance_handles_lua(extraction_dir: str, output_path: str | None = None) -> str:
    if output_path is None:
        output_path = os.path.join(extraction_dir, 'instance.lua')
    instances = _collect_instances(extraction_dir)
    lua_src = _emit_lua(instances)
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    with open(output_path, 'w', encoding='utf-8', newline='\n') as f:
        f.write(lua_src)
    return output_path


if __name__ == '__main__':
    import sys
    if len(sys.argv) < 2 or len(sys.argv) > 3:
        print('Usage: python tools/generate_instance_handles_lua.py <extraction_dir> [output_path]')
        raise SystemExit(1)
    out = generate_instance_handles_lua(sys.argv[1], sys.argv[2] if len(sys.argv) == 3 else None)
    print(f"✅ instance.lua généré: {out}")






